}
N = my_binomial(n=30,k=3)
# symbols of all S&P500 stocks
sp500 <- read_html("https://en.wikipedia.org/wiki/List_of_S%26P_500_companies")
sp500 %>%
html_nodes(".text") %>%
html_text() -> ticker_sp500
SP500_symbol <- ticker_sp500[(1:499)*2+1]
SP500_symbol[SP500_symbol == "BRK.B"] <- "BRK-B"
SP500_symbol[SP500_symbol == "BF.B"] <- "BF-B"
# only consider the top 30 companies of the S&P500 listed below
stocks_considered = c("ADBE", "BA", "WFC", "PEP", "CMCSA", "CSCO", "CVX", "PFE", "MRK", "VZ", "KO", "DIS", "HD", "XOM",  "UNH", "T", "INTC", "BAC",  "PG", "MA", "WMT", "JNJ", "JMP", "V", "BRK-B", "FB", "GOOGL", "AMZN", "AAPL", "MSFT")
# load data
L = length(stocks_considered)
S = 1
stocks_tickers = matrix(NA, N+1, 3  )
three_year_ago <- seq(as.Date("2020-04-01"), length = 2, by = "-3 year")[2]
for(i in 1:(L-2)){
for(j in (i+1):(L-1)){
for(k in (j+1):L){
stocks_tickers[S,] <- c(stocks_considered[i],stocks_considered[j], stocks_considered[k])
S = S + 1
}
}
}
for (i in 1:30) {
getSymbols(stocks_considered[i], from = three_year_ago, to = as.Date("2020-04-01"))
}
investment_summary = matrix(NA, N+1, 2)
for(j in 1:(N)){
# get variance of the returns
nb_ticker <- length(stocks_tickers[j,])
for (i in 1:nb_ticker){
Xt = na.omit(ClCl(get(stocks_tickers[j, i])))
if(i == 1){
At = Xt
}else if(i == 2){
Bt = Xt
}else{
Ct = Xt
}
}
# Estimation of mu and Sigma peut etre mis en fonction
mat_return = cbind(At, Bt, Ct)
colnames(mat_return) = c(stocks_tickers[j,1],stocks_tickers[j,2], stocks_tickers[j,3])
Cov_mat = var(mat_return)
# find optimal weight Peut etre mis en fonction
one = rep(1,3)
inv_Sigma = solve(Cov_mat)
inv_Sigma
W = as.numeric(inv_Sigma %*% one / as.numeric(t(one) %*% inv_Sigma %*% one))
# optimal portfolio
optim_return = At*W[1] + Bt*W[2] + Ct*W[3]
mu_optim = mean(optim_return)
var_optim = var(optim_return)
investment_summary[j, 1] = mu_optim
investment_summary[j, 2] = var_optim
}
minimum <- investment_summary[1, ]
for(j in 1:(N-1)){
if( minimum[2] > investment_summary[j+1, 2]){
minimum[1]= investment_summary[j+1, 1]
minimum[2]= investment_summary[j+1, 2]
}
}
library(yarrr)
plot(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
ylab = "Investement Daily Expected Return",
xlab = "Investement Daily Risk",
pch = 19, cex = 0.5, lty = "solid", lwd = 2,
xlim = c(min(sqrt(investment_summary[ , 2]))-0.001, max(sqrt(investment_summary[ , 2])+0.001)),
col = transparent("steelblue3", trans.val = .8), main = "Minimum-Variance Portfolio")
points(sqrt(minimum[2]), minimum[1],pch = 19 , col = transparent("red4", trans.val = .3), cex = 0.5)
grid()
text(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
labels = names(investment_summary[1, ]), cex= 0.7, pos = 4)
library(quantmod)
library(rvest)
my_factorial = function(x){
# Base case
if(x == 0){
return(1)
}else if(x == 1){
return(1)
# Recursive call
}else{
return(x*my_factorial(x-1))
}
}
#Number of all possibility combination of three stocks
my_binomial = function(n, k){
(my_factorial(n))/(my_factorial(k)*my_factorial(n-k))
}
N = my_binomial(n=30,k=3)
# symbols of all S&P500 stocks
sp500 <- read_html("https://en.wikipedia.org/wiki/List_of_S%26P_500_companies")
sp500 %>%
html_nodes(".text") %>%
html_text() -> ticker_sp500
SP500_symbol <- ticker_sp500[(1:499)*2+1]
SP500_symbol[SP500_symbol == "BRK.B"] <- "BRK-B"
SP500_symbol[SP500_symbol == "BF.B"] <- "BF-B"
# only consider the top 30 companies of the S&P500 listed below
stocks_considered = c("ADBE", "BA", "WFC", "PEP", "CMCSA", "CSCO", "CVX", "PFE", "MRK", "VZ", "KO", "DIS", "HD", "XOM",  "UNH", "T", "INTC", "BAC",  "PG", "MA", "WMT", "JNJ", "JMP", "V", "BRK-B", "FB", "GOOGL", "AMZN", "AAPL", "MSFT")
# load data
L = length(stocks_considered)
S = 1
stocks_tickers = matrix(NA, N+1, 3  )
three_year_ago <- seq(as.Date("2020-04-01"), length = 2, by = "-3 year")[2]
for(i in 1:(L-2)){
for(j in (i+1):(L-1)){
for(k in (j+1):L){
stocks_tickers[S,] <- c(stocks_considered[i],stocks_considered[j], stocks_considered[k])
S = S + 1
}
}
}
for (i in 1:30) {
getSymbols(stocks_considered[i], from = three_year_ago, to = as.Date("2020-04-01"))
}
investment_summary = matrix(NA, N+1, 2)
for(j in 1:(N)){
# get variance of the returns
nb_ticker <- length(stocks_tickers[j,])
for (i in 1:nb_ticker){
Xt = na.omit(ClCl(get(stocks_tickers[j, i])))
if(i == 1){
At = Xt
}else if(i == 2){
Bt = Xt
}else{
Ct = Xt
}
}
# Estimation of mu and Sigma peut etre mis en fonction
mat_return = cbind(At, Bt, Ct)
colnames(mat_return) = c(stocks_tickers[j,1],stocks_tickers[j,2], stocks_tickers[j,3])
Cov_mat = var(mat_return)
# find optimal weight Peut etre mis en fonction
one = rep(1,3)
inv_Sigma = solve(Cov_mat)
inv_Sigma
W = as.numeric(inv_Sigma %*% one / as.numeric(t(one) %*% inv_Sigma %*% one))
# optimal portfolio
optim_return = At*W[1] + Bt*W[2] + Ct*W[3]
mu_optim = mean(optim_return)
var_optim = var(optim_return)
investment_summary[j, 1] = mu_optim
investment_summary[j, 2] = var_optim
}
minimum <- investment_summary[1, ]
for(j in 1:(N-1)){
if( minimum[2] > investment_summary[j+1, 2]){
minimum[1]= investment_summary[j+1, 1]
minimum[2]= investment_summary[j+1, 2]
}
}
library(yarrr)
plot(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
ylab = "Investement Daily Expected Return",
xlab = "Investement Daily Risk",
pch = 19, cex = 0.5, lty = "solid", lwd = 2,
xlim = c(min(sqrt(investment_summary[ , 2]))-0.001, max(sqrt(investment_summary[ , 2])+0.001)),
col = transparent("steelblue3", trans.val = .8), main = "Minimum-Variance Portfolio")
points(sqrt(minimum[2]), minimum[1],pch = 19 , col = transparent("red4", trans.val = .3), cex = 0.5)
grid()
text(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
labels = names(investment_summary[1, ]), cex= 0.7, pos = 4)
library(rvest)
my_factorial = function(x){
# Base case
if(x == 0){
return(1)
}else if(x == 1){
return(1)
# Recursive call
}else{
return(x*my_factorial(x-1))
}
}
#Number of all possibility combination of three stocks
my_binomial = function(n, k){
(my_factorial(n))/(my_factorial(k)*my_factorial(n-k))
}
N = my_binomial(n=30,k=3)
# symbols of all S&P500 stocks
sp500 <- read_html("https://en.wikipedia.org/wiki/List_of_S%26P_500_companies")
sp500 %>%
html_nodes(".text") %>%
html_text() -> ticker_sp500
SP500_symbol <- ticker_sp500[(1:499)*2+1]
SP500_symbol[SP500_symbol == "BRK.B"] <- "BRK-B"
SP500_symbol[SP500_symbol == "BF.B"] <- "BF-B"
# only consider the top 30 companies of the S&P500 listed below
stocks_considered = c("ADBE", "BA", "WFC", "PEP", "CMCSA", "CSCO", "CVX", "PFE", "MRK", "VZ", "KO", "DIS", "HD", "XOM",  "UNH", "T", "INTC", "BAC",  "PG", "MA", "WMT", "JNJ", "JMP", "V", "BRK-B", "FB", "GOOGL", "AMZN", "AAPL", "MSFT")
# load data
L = length(stocks_considered)
S = 1
stocks_tickers = matrix(NA, N+1, 3  )
three_year_ago <- seq(as.Date("2020-04-01"), length = 2, by = "-3 year")[2]
for(i in 1:(L-2)){
for(j in (i+1):(L-1)){
for(k in (j+1):L){
stocks_tickers[S,] <- c(stocks_considered[i],stocks_considered[j], stocks_considered[k])
S = S + 1
}
}
}
for (i in 1:30) {
getSymbols(stocks_considered[i], from = three_year_ago, to = as.Date("2020-04-01"))
}
investment_summary = matrix(NA, N+1, 2)
for(j in 1:(N)){
# get variance of the returns
nb_ticker <- length(stocks_tickers[j,])
for (i in 1:nb_ticker){
Xt = na.omit(ClCl(get(stocks_tickers[j, i])))
if(i == 1){
At = Xt
}else if(i == 2){
Bt = Xt
}else{
Ct = Xt
}
}
# Estimation of mu and Sigma peut etre mis en fonction
mat_return = cbind(At, Bt, Ct)
colnames(mat_return) = c(stocks_tickers[j,1],stocks_tickers[j,2], stocks_tickers[j,3])
Cov_mat = var(mat_return)
# find optimal weight Peut etre mis en fonction
one = rep(1,3)
inv_Sigma = solve(Cov_mat)
inv_Sigma
W = as.numeric(inv_Sigma %*% one / as.numeric(t(one) %*% inv_Sigma %*% one))
# optimal portfolio
optim_return = At*W[1] + Bt*W[2] + Ct*W[3]
mu_optim = mean(optim_return)
var_optim = var(optim_return)
investment_summary[j, 1] = mu_optim
investment_summary[j, 2] = var_optim
}
minimum <- investment_summary[1, ]
for(j in 1:(N-1)){
if( minimum[2] > investment_summary[j+1, 2]){
minimum[1]= investment_summary[j+1, 1]
minimum[2]= investment_summary[j+1, 2]
}
}
library(yarrr)
plot(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
ylab = "Investement Daily Expected Return",
xlab = "Investement Daily Risk",
pch = 19, cex = 0.5, lty = "solid", lwd = 2,
xlim = c(min(sqrt(investment_summary[ , 2]))-0.001, max(sqrt(investment_summary[ , 2])+0.001)),
col = transparent("steelblue3", trans.val = .8), main = "Minimum-Variance Portfolio")
points(sqrt(minimum[2]), minimum[1],pch = 19 , col = transparent("red4", trans.val = .3), cex = 0.5)
grid()
text(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
labels = names(investment_summary[1, ]), cex= 0.7, pos = 4)
library(quantmod)
library(rvest)
my_factorial = function(x){
# Base case
if(x == 0){
return(1)
}else if(x == 1){
return(1)
# Recursive call
}else{
return(x*my_factorial(x-1))
}
}
#Number of all possibility combination of three stocks
my_binomial = function(n, k){
(my_factorial(n))/(my_factorial(k)*my_factorial(n-k))
}
N = my_binomial(n=30,k=3)
# symbols of all S&P500 stocks
sp500 <- read_html("https://en.wikipedia.org/wiki/List_of_S%26P_500_companies")
sp500 %>%
html_nodes(".text") %>%
html_text() -> ticker_sp500
SP500_symbol <- ticker_sp500[(1:499)*2+1]
SP500_symbol[SP500_symbol == "BRK.B"] <- "BRK-B"
SP500_symbol[SP500_symbol == "BF.B"] <- "BF-B"
# only consider the top 30 companies of the S&P500 listed below
stocks_considered = c("ADBE", "BA", "WFC", "PEP", "CMCSA", "CSCO", "CVX", "PFE", "MRK", "VZ", "KO", "DIS", "HD", "XOM",  "UNH", "T", "INTC", "BAC",  "PG", "MA", "WMT", "JNJ", "JMP", "V", "BRK-B", "FB", "GOOGL", "AMZN", "AAPL", "MSFT")
# load data
L = length(stocks_considered)
S = 1
stocks_tickers = matrix(NA, N+1, 3  )
three_year_ago <- seq(as.Date("2020-04-01"), length = 2, by = "-3 year")[2]
for(i in 1:(L-2)){
for(j in (i+1):(L-1)){
for(k in (j+1):L){
stocks_tickers[S,] <- c(stocks_considered[i],stocks_considered[j], stocks_considered[k])
S = S + 1
}
}
}
for (i in 1:30) {
getSymbols(stocks_considered[i], from = three_year_ago, to = as.Date("2020-04-01"))
}
investment_summary = matrix(NA, N+1, 2)
for(j in 1:(N)){
# get variance of the returns
nb_ticker <- length(stocks_tickers[j,])
for (i in 1:nb_ticker){
Xt = na.omit(ClCl(get(stocks_tickers[j, i])))
if(i == 1){
At = Xt
}else if(i == 2){
Bt = Xt
}else{
Ct = Xt
}
}
# Estimation of mu and Sigma peut etre mis en fonction
mat_return = cbind(At, Bt, Ct)
colnames(mat_return) = c(stocks_tickers[j,1],stocks_tickers[j,2], stocks_tickers[j,3])
Cov_mat = var(mat_return)
# find optimal weight Peut etre mis en fonction
one = rep(1,3)
inv_Sigma = solve(Cov_mat)
inv_Sigma
W = as.numeric(inv_Sigma %*% one / as.numeric(t(one) %*% inv_Sigma %*% one))
# optimal portfolio
optim_return = At*W[1] + Bt*W[2] + Ct*W[3]
mu_optim = mean(optim_return)
var_optim = var(optim_return)
investment_summary[j, 1] = mu_optim
investment_summary[j, 2] = var_optim
}
minimum <- investment_summary[1, ]
for(j in 1:(N-1)){
if( minimum[2] > investment_summary[j+1, 2]){
minimum[1]= investment_summary[j+1, 1]
minimum[2]= investment_summary[j+1, 2]
}
}
library(yarrr)
plot(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
ylab = "Investement Daily Expected Return",
xlab = "Investement Daily Risk",
pch = 19, cex = 0.5, lty = "solid", lwd = 2,
xlim = c(min(sqrt(investment_summary[ , 2]))-0.001, max(sqrt(investment_summary[ , 2])+0.001)),
col = transparent("steelblue3", trans.val = .8), main = "Minimum-Variance Portfolio")
points(sqrt(minimum[2]), minimum[1],pch = 19 , col = transparent("red4", trans.val = .3), cex = 0.5)
grid()
text(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
labels = names(investment_summary[1, ]), cex= 0.7, pos = 4)
install.packages("quantmod")
install.packages("quantmod")
llibrary(quantmod)
library(quantmod)
install.packages("rvest")
library(rvest)
install.packages("BayesFactor")
library(BayesFactor)
library(quantmod)
library(rvest)
my_factorial = function(x){
# Base case
if(x == 0){
return(1)
}else if(x == 1){
return(1)
# Recursive call
}else{
return(x*my_factorial(x-1))
}
}
#Number of all possibility combination of three stocks
my_binomial = function(n, k){
(my_factorial(n))/(my_factorial(k)*my_factorial(n-k))
}
N = my_binomial(n=30,k=3)
# symbols of all S&P500 stocks
sp500 <- read_html("https://en.wikipedia.org/wiki/List_of_S%26P_500_companies")
sp500 %>%
html_nodes(".text") %>%
html_text() -> ticker_sp500
SP500_symbol <- ticker_sp500[(1:499)*2+1]
SP500_symbol[SP500_symbol == "BRK.B"] <- "BRK-B"
SP500_symbol[SP500_symbol == "BF.B"] <- "BF-B"
# only consider the top 30 companies of the S&P500 listed below
stocks_considered = c("ADBE", "BA", "WFC", "PEP", "CMCSA", "CSCO", "CVX", "PFE", "MRK", "VZ", "KO", "DIS", "HD", "XOM",  "UNH", "T", "INTC", "BAC",  "PG", "MA", "WMT", "JNJ", "JMP", "V", "BRK-B", "FB", "GOOGL", "AMZN", "AAPL", "MSFT")
# load data
L = length(stocks_considered)
S = 1
stocks_tickers = matrix(NA, N+1, 3  )
three_year_ago <- seq(as.Date("2020-04-01"), length = 2, by = "-3 year")[2]
for(i in 1:(L-2)){
for(j in (i+1):(L-1)){
for(k in (j+1):L){
stocks_tickers[S,] <- c(stocks_considered[i],stocks_considered[j], stocks_considered[k])
S = S + 1
}
}
}
for (i in 1:30) {
getSymbols(stocks_considered[i], from = three_year_ago, to = as.Date("2020-04-01"))
}
investment_summary = matrix(NA, N+1, 2)
for(j in 1:(N)){
# get variance of the returns
nb_ticker <- length(stocks_tickers[j,])
for (i in 1:nb_ticker){
Xt = na.omit(ClCl(get(stocks_tickers[j, i])))
if(i == 1){
At = Xt
}else if(i == 2){
Bt = Xt
}else{
Ct = Xt
}
}
# Estimation of mu and Sigma peut etre mis en fonction
mat_return = cbind(At, Bt, Ct)
colnames(mat_return) = c(stocks_tickers[j,1],stocks_tickers[j,2], stocks_tickers[j,3])
Cov_mat = var(mat_return)
# find optimal weight Peut etre mis en fonction
one = rep(1,3)
inv_Sigma = solve(Cov_mat)
inv_Sigma
W = as.numeric(inv_Sigma %*% one / as.numeric(t(one) %*% inv_Sigma %*% one))
# optimal portfolio
optim_return = At*W[1] + Bt*W[2] + Ct*W[3]
mu_optim = mean(optim_return)
var_optim = var(optim_return)
investment_summary[j, 1] = mu_optim
investment_summary[j, 2] = var_optim
}
minimum <- investment_summary[1, ]
for(j in 1:(N-1)){
if( minimum[2] > investment_summary[j+1, 2]){
minimum[1]= investment_summary[j+1, 1]
minimum[2]= investment_summary[j+1, 2]
}
}
library(yarrr)
plot(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
ylab = "Investement Daily Expected Return",
xlab = "Investement Daily Risk",
pch = 19, cex = 0.5, lty = "solid", lwd = 2,
xlim = c(min(sqrt(investment_summary[ , 2]))-0.001, max(sqrt(investment_summary[ , 2])+0.003)),
col = transparent("steelblue3", trans.val = .8), main = "Minimum-Variance Portfolio")
points(sqrt(minimum[2]), minimum[1],pch = 19 , col = transparent("red4", trans.val = .3), cex = 0.8)
grid()
text(sqrt(investment_summary[ , 2]), investment_summary[ , 1],
labels = names(investment_summary[1, ]), cex= 0.7, pos = 4)
legend("topright", legend=c("Possible portfolio", "Min-varianfce portfolio"),
col = c("steelblue3", "red4"), pch = 19, cex = 0.8, bty = "n")
install.packages(spotifyr)
install.packages("spotifyr")
library(spotifyr)
install.packages('spotifyr')
devtools::install_github('charlie86/spotifyr')
library(spotifyr)
View(ap)
install.packages("Rspotify")
library(Rspotify)
library(shiny); runApp('Desktop/GSEM/Data science/Intro_DS_Project/Spotify_app.R')
library(shiny); runApp('Spotify_app.R')
library(shiny); runApp('Spotify_app.R')
library(shiny); runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('eo Spotify.R')
runApp('~/Desktop/HLM')
runApp('Spotify_app.R')
library(shiny); runApp('Spotify_app.R')
<<<<<<< HEAD
=======
runApp('Spotify_app.R')
<<<<<<< HEAD
runApp('eo Spotify.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
library(shiny); runApp('Spotify_app.R')
library(shiny); runApp('eo Spotify.R')
runApp('~/Desktop/HLM')
install.packages(jsonlite)
library(shiny); runApp('Spotify_app.R')
runApp('Spotify_app.R')
library(shiny); runApp('Spotify_app.R')
=======
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
<<<<<<< HEAD
library(shiny); runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
=======
>>>>>>> e75f6b6ce82d35e878559c1f8110082ec74aa379
>>>>>>> 34fe0a6fb680f1ab815f1c48c78ebfa5a92f86b0
>>>>>>> 7110559279db1ca0d1600255c5047216fe8f1aff
library(shiny); runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
runApp('Spotify_app.R')
library(shiny); runApp('Spotify_app.R')
